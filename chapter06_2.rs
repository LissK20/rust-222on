#[test]
fn test1()
{
    // Заповніть пропуск правильним типом масиву
    let arr: [i32; 5] = [1, 2, 3, 4, 5]; // Вказано тип масиву з 5 елементів

    // Змініть код нижче, щоб він працював правильно
    assert!(arr.len() == 5); // Змінено на 5, оскільки масив має 5 елементів

    println!("Успіх!");
}

#[test]
fn test2()
{
    // Ми можемо ігнорувати частини типу масиву або навіть увесь тип, нехай компілятор виводить його для нас
    let arr0 = [1, 2, 3];
    let arr: [_; 3] = ['a', 'b', 'c'];

    // Заповніть пропуск
    // Масиви виділяються на стеку, `std::mem::size_of_val` повертає байти, які займає масив
    // Символ займає 4 байти у Rust: Unicode символ
    assert!(std::mem::size_of_val(&arr) == 12); // 3 символи * 4 байти = 12 байтів

    println!("Успіх!");
}

#[test]
fn test3()
{
    // Заповніть пропуск
    let list: [i32; 100] = [1; 100]; // Всі елементи масиву ініціалізуються значенням 1

    assert!(list[0] == 1);
    assert!(list.len() == 100);

    println!("Успіх!");
}

#[test]
fn test4()
{
    // Виправлено, усі елементи - цілі числа
    let _arr = [1, 2, 3]; // Змінено '3' на 3

    println!("Успіх!");
}

fn test4_2()
{
    // Виправлено, усі елементи - символи
    let _arr = ['1', '2', '3']; // Змінено 1 і 2 на символи '1' і '2'

    println!("Успіх!");
}

#[test]
fn test5()
{
    let arr = ['a', 'b', 'c'];

    let ele = arr[0]; // Змінено на 0, щоб отримати перший елемент

    assert!(ele == 'a');

    println!("Успіх!");
}

#[test]
fn test6()
{
    let names = [String::from("Sunfei"), "Sunface".to_string()];

    // `get` повертає Option<T>, тому його безпечно використовувати
    let name0 = names.get(0).unwrap();

    // Зміна індексу на 1, щоб отримати другий елемент
    let name1 = &names[1]; // Змінено з [2] на [1]

    println!("Успіх!");
}